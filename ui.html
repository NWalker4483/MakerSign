<!DOCTYPE html>
<html>

<head>
    <title></title>
    <meta charset='utf-8'>
    <style>
        body {
            margin: 0;
        }

        .canvas-container {
            position: relative;
            width: 500px;
            height: 500px;
        }

        canvas {
            position: absolute;
            position: absolute;
            left: 0px;
            top: 0px;
        }

        table {
            position: absolute;
            left: 0%;
            top: 0%;
            z-index: 3;
        }

        button {
            background-color: #1e45f4;
            border: none;
            color: black;
            width: 180px;
            padding: 16px 32px;
            text-align: center;
            font-size: 16px;
            margin: 4px 2px;
            opacity: 0.6;
            transition: 0.3s;
            border: 5px;
            border-color: black;
            display: inline-block;
            cursor: pointer;
        }

        button:hover {
            opacity: 1
        }
    </style>

    <script src='https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js'></script>
</head>

<body>
    <div class="canvas-container">
        <canvas id='paint_layer' style='z-index: 1;'></canvas>
        <canvas id='word_layer' style='z-index: 2;'></canvas>
    </div>

    <div>
        <table>
            <tr>
                <th>Effects</th>
                <th></th>
            </tr>
            <tr>
                <td><button value="Rainbow">Rainbow</button>
                </td>
            </tr>
            <tr>
                <td><button>Rain</button></td>
            </tr>
            <tr>
                <td><button value="Bounce">Bounce</button></td>
            </tr>
            <tr>
                <td><button>Paint</button></td>
            </tr>
            <tr>
                <td><input type='color' id='color'></button></td>
            </tr>
            <tr>
                <td><button type='button' id='reset'>Reset Canvas</button></td>
            </tr>
        </table>


    </div>
    <script>
        // Main Function 
        (function (w, d) {
            'use strict';

            var current_effect = "",
                canvas = d.querySelector('#paint_layer'),
                paint_ctx = canvas.getContext('2d'),
                color = d.querySelector('#color'),
                offset = 1000,
                points = [],
                bufer = paint_ctx.getImageData(0, 0, canvas.width, canvas.height),
                led_counts = { 0: 151, 1: 57, 2: 10, 3: 10, 4: 10, 5: 10, 6: 10, 7: 10, 8: 10, 9: 10 },
                control_points = { 0: [[0, 0]], 1: [[0, 0]], 2: [[0, 0]], 3: [[0, 0]], 4: [[0, 0]], 5: [[0, 0]], 6: [[0, 0]], 7: [[0, 0]], 8: [[0, 0]], 9: [[0, 0]] },
                point_history = {};
            // Setup Canvases 
            paint_ctx.shadowColor = '#000000';
            canvas.height = w.innerHeight;
            canvas.width = w.innerWidth;
            words.height = w.innerHeight;
            words.width = w.innerWidth;

            // Setup Guide text  
            words_ctx = d.querySelector('#word_layer').getContext('2d');
            words_ctx.lineWidth = 3;
            words_ctx.strokeStyle = 'black';
            words_ctx.font = ' 250px serif';
            words_ctx.strokeText('MakerSPACe', 0, canvas.height / 2);

            // Arduino Commanding Tools 
            const buffer = new ArrayBuffer(5);
            // var connection = new WebSocket('ws://' + w.location.hostname + ':81/', ['arduino']);
            // connection.onopen = function () {
            //     connection.send('Connect ' + new Date());
            // };
            // connection.onerror = function (error) {
            //     console.log('WebSocket Error ', error);
            // };
            // connection.binaryType = 'arraybuffer';
            // connection.onmessage = function (e) {
            //     console.log('Server: ', e.data);
            // };
            // connection.onclose = function () {
            //     console.log('WebSocket connection closed');
            // };

            function samplePoint(x, y) {
                var img_data = paint_ctx.getImageData(x, y, 1, 1).data;
                var R = img_data[0];
                var G = img_data[1];
                var B = img_data[2];
                return [R, G, B];
            }
            function sampleCapturePoints() {
                for (const [device_num, points] of Object.entries(control_points)) {
                    for (const [index, point] of Object.entries(points)) {
                        var rgb = samplePoint(point[0], point[1]);
                        var led_ind = device_num.toString() + index.toString().padStart(3, "0");
                        var cmd = rgb[0].toString().padStart(3, "0") + rgb[1].toString().padStart(3, "0") + rgb[2].toString().padStart(3, "0");
                        var bytearray = new Uint8Array(buffer);
                        bytearray[0] = device_num;
                        bytearray[1] = index;
                        bytearray[2] = rgb[0];
                        bytearray[3] = rgb[1];
                        bytearray[4] = rgb[2];

                        if (point_history[led_ind] != cmd) {
                            // if (connection.readyState === WebSocket.OPEN) {
                            //     connection.send(bytearray.buffer);
                            // } else {
                            console.log(bytearray);
                            // }
                            point_history[led_ind] = cmd;
                        }
                    }
                }
            }

            // Mouse State Tools
            const mouse = { x: 0, y: 0, button: false, drag: false, dragStart: false, dragEnd: false, dragStartX: 0, dragStartY: 0 }
            function mouseEvents(e) {
                mouse.x = e.pageX;
                mouse.y = e.pageY;
                const lb = mouse.button;
                mouse.button = e.type === "mousedown" ? true : e.type === "mouseup" ? false : mouse.button;
                if (lb !== mouse.button) {
                    if (mouse.button) {
                        mouse.drag = true;
                        mouse.dragStart = true;
                        mouse.dragStartX = mouse.x;
                        mouse.dragStartY = mouse.y;
                    } else {
                        mouse.drag = false;
                        mouse.dragEnd = true;
                    }
                }
            }
            ["down", "up", "move"].forEach(name => document.addEventListener("mouse" + name, mouseEvents));
            // Paint Tools 
            d.getElementById('reset').onclick = resetCanvas;
            function resetCanvas() {
                paint_ctx.clearRect(0, 0, canvas.width, canvas.height);
                paint_ctx.lineWidth = 50;
                paint_ctx.shadowBlur = 100;
                bufer = paint_ctx.getImageData(0, 0, canvas.width, canvas.height);
            }
            function runCanvas() {
                if (mouse.drag) {
                    paint_ctx.putImageData(bufer, 0, 0); // Redraw Previous Frame 
                    points.push([e.pageX, e.pageY]);
                }
                if (mouse.dragEnd) {
                    points = [];
                    bufer = paint_ctx.getImageData(0, 0, canvas.width, canvas.height);
                }
                sampleCapturePoints();
                setTimeout(runCanvas, 1000 / 24); // drawing at 24fps
            }            
            paint_ctx.beginPath();
            paint_ctx.moveTo(points[0][0] + offset, points[0][1]);
            for (var i = 1; i < points.length; i++) {
                paint_ctx.lineTo(points[i][0] + offset, points[i][1]);
            }

            //////////////////// ALL EFFECTS

            const ctx = canvas.getContext("2d");
            const Point2 = (x, y) => ({ x, y });  // creates a point
            const Line = (p1, p2) => ({ p1, p2 });
            const setStyle = (style) => eachOf(Object.keys(style), key => { ctx[key] = style[key] });
            const eachOf = (array, callback) => { var i = 0; while (i < array.length && callback(array[i], i++) !== true); };

            const list = {
                items: null,
                add(item) { this.items.push(item); return item },
                eachItem(callback) {
                    var i = 0;
                    while (i < this.items.length) {
                        callback(this.items[i], i++);
                    }
                }
            }
            function createList(extend) {
                return Object.assign({}, list, { items: [] }, extend);
            }
            // this will extend the points list
            function getClosestPoint(from, minDist) {
                var closestPoint;
                this.eachItem(point => {
                    const dist = Math.hypot(from.x - point.x, from.y - point.y);
                    if (dist < minDist) {
                        closestPoint = point;
                        minDist = dist;
                    }
                });
                return closestPoint;
            }
            function distanceLineFromPoint(line, point) {
                const lx = points.items[line.p1].x;
                const ly = points.items[line.p1].y;
                const v1x = points.items[line.p2].x - lx;
                const v1y = points.items[line.p2].y - ly;
                const v2x = point.x - lx;
                const v2y = point.y - ly;
                // get unit dist of closest point
                const u = (v2x * v1x + v2y * v1y) / (v1y * v1y + v1x * v1x);
                if (u >= 0 && u <= 1) {  // is the point on the line
                    return Math.hypot(lx + v1x * u - point.x, ly + v1y * u - point.y);
                } else if (u < 0) {  // point is before start
                    return Math.hypot(lx - point.x, ly - point.y);
                }
                // point is after end of line
                return Math.hypot(points.items[line.p2].x - point.x, points.items[line.p2].y - point.y);
            }
            // this will extend the lines list
            function getClosestline(from, minDist) {
                var closestLine;
                this.eachItem(line => {
                    const dist = distanceLineFromPoint(line, from);
                    if (dist < minDist) {
                        closestLine = line;
                        minDist = dist;
                    }
                });
                return closestLine;
            }
            function drawPoint(point) {
                ctx.moveTo(point.x, point.y);
                ctx.rect(point.x - 2, point.y - 2, 4, 4);
            }
            function drawLine(line) {
                ctx.moveTo(points.items[line.p1].x, points.items[line.p1].y);
                ctx.lineTo(points.items[line.p2].x, points.items[line.p2].y);
            }
            function drawLines() { this.eachItem(line => drawLine(line)) }
            function drawPoints() { this.eachItem(point => drawPoint(point)) }

            const points = createList({
                getClosest: getClosestPoint,
                draw: drawPoints,
            });
            const lines = createList({
                getClosest: getClosestline,
                draw: drawLines,
            });


            // short cut vars 
            var w = canvas.width;
            var h = canvas.height;

            var closestLine;
            var closestPoint;
            var pointDrag; // true is dragging a point else dragging a line
            var dragOffsetX;
            var dragOffsetY;
            var cursor;
            const minDist = 20;
            const lineStyle = {
                lineWidth: 2,
                strokeStyle: "green",
            }
            const pointStyle = {
                lineWidth: 1,
                strokeStyle: "blue",
            }
            const highlightStyle = {
                lineWidth: 3,
                strokeStyle: "red",
            }

            //<!--https://stackoverflow.com/questions/44923395/making-each-canvas-line-draggable-and-droppable/44926740#44926740?newreg=e1bdf9d77e044f4399c2edb6dfde93aa-->
            function Update() {
                cursor = "crosshair";
                ctx.setTransform(1, 0, 0, 1, 0, 0); // reset transform
                ctx.globalAlpha = 1;           // reset alpha
                if (w !== innerWidth || h !== innerHeight) {
                    (w = canvas.width = innerWidth) / 2;
                    (h = canvas.height = innerHeight) / 2;
                } else {
                    ctx.clearRect(0, 0, w, h);
                }
                if (mouse.drag === false) {
                    closestLine = undefined;
                    closestPoint = points.getClosest(mouse, minDist);
                    if (closestPoint === undefined) {
                        closestLine = lines.getClosest(mouse, minDist);
                    }
                    if (closestPoint || closestLine) {
                        cursor = "move";
                    }
                }
                if (mouse.dragStart) {
                    if (closestPoint) {
                        dragOffsetX = closestPoint.x - mouse.x;
                        dragOffsetY = closestPoint.y - mouse.y;
                        pointDrag = true;

                    } else if (closestLine) {
                        dragOffsetX = points.items[closestLine.p1].x - mouse.x;
                        dragOffsetY = points.items[closestLine.p1].y - mouse.y;
                        pointDrag = false;

                    } else {
                        points.add(Point2(mouse.x, mouse.y));
                        closestPoint = points.add(Point2(mouse.x, mouse.y));
                        closestLine = lines.add(Line(points.items.length - 2, points.items.length - 1));
                        dragOffsetX = 0;
                        dragOffsetY = 0;
                        pointDrag = true;

                    }
                    mouse.dragStart = false;

                } else if (mouse.drag) {
                    cursor = 'none';
                    if (pointDrag) {
                        closestPoint.x = mouse.x + dragOffsetX;
                        closestPoint.y = mouse.y + dragOffsetY;
                    } else {
                        const dx = mouse.x - mouse.dragStartX;
                        const dy = mouse.y - mouse.dragStartY;
                        mouse.dragStartX = mouse.x;
                        mouse.dragStartY = mouse.y;
                        points.items[closestLine.p1].x += dx;
                        points.items[closestLine.p1].y += dy;
                        points.items[closestLine.p2].x += dx;
                        points.items[closestLine.p2].y += dy;
                    }
                }

                // draw all points and lines
                setStyle(lineStyle);
                ctx.beginPath();
                lines.draw();
                ctx.stroke();
                setStyle(pointStyle);
                ctx.beginPath();
                points.draw();
                ctx.stroke();

                // draw highlighted point or line
                setStyle(highlightStyle);
                ctx.beginPath();
                if (closestLine) { drawLine(closestLine) }
                if (closestPoint) { drawPoint(closestPoint) }

                ctx.stroke();
                canvas.style.cursor = cursor;
                if (current_effect == "Update") {
                    requestAnimationFrame(Update);
                }
            }
            // Rainbow Effect
            var angle = Math.random() * 360,        // start angle (for HSL)      
                step = 1;                            // "speed" for change
            function createRainbowGradient() {
                var angleDlt = 60; // 60° ahead
                var gr = paint_ctx.createLinearGradient(0, 0, canvas.width / 2, 0);               // create gradient
                gr.addColorStop(0, "hsl(" + (angle % 360) + ",100%, 50%)");    // start color
                gr.addColorStop(0.5, "hsl(" + ((angle + (angleDlt / 2)) % 360) + ",100%, 50%)");
                gr.addColorStop(1, "hsl(" + ((angle + angleDlt) % 360) + ",100%, 50%)");
                paint_ctx.fillStyle = gr;                                            // set as fill style
                paint_ctx.fillRect(0, 0, canvas.width, canvas.height);                                  // fill area   
                angle += step;
                if (current_effect == "Rainbow") {
                    requestAnimationFrame(createRainbowGradient);
                }
            }
            // Bounce Effect 
            var angle = 0;
            function Bounce() {
                paint_ctx.clearRect(0, 0, canvas.width, canvas.height);

                // color in the background
                paint_ctx.fillStyle = "#EEEEEE";
                paint_ctx.fillRect(0, 0, canvas.width, canvas.height);

                // draw the circle
                paint_ctx.beginPath();

                var radius = 25 + 500 * Math.abs(Math.cos(angle));
                paint_ctx.shadowBlur = 1;
                paint_ctx.shadowOffsetX = 0;
                paint_ctx.arc(canvas.width / 3, canvas.height / 2, radius, 0, Math.PI * 2, false);
                paint_ctx.closePath();

                // color in the circle
                paint_ctx.fillStyle = paint_ctx.shadowColor;
                paint_ctx.fill();

                angle += Math.PI / 128;
                if (current_effect == "Bounce") {
                    requestAnimationFrame(drawCircle);
                }
            }
            // Effect Switching Handler 
            $("button").click(function () {

                if ($(this).val() == "Rainbow" && current_effect != "Rainbow") {
                    angle = Math.random() * 360,        // start angle (for HSL)
                        angleDlt = 60,                    // 60° ahead
                        step = 1;
                    requestAnimationFrame(createRainbowGradient);
                }

                if ($(this).val() == "Bounce" && current_effect != "Bounce") {

                    angle = 0;

                    requestAnimationFrame(Bounce);
                }
                if ($(this).val() == "Paint" && current_effect != "Paint") {

                    //requestAnimationFrame(drawCircle);
                    /*
                       paint_ctx.beginPath();
                        paint_ctx.moveTo(points[0][0] + offset, points[0][1]);
                        for (var i = 1; i < points.length; i++) {
                            paint_ctx.lineTo(points[i][0] + offset, points[i][1]);
                        }
                        */
                }
                if ($(this).val() == "Update" && current_effect != "Update") {
                    requestAnimationFrame(Update);
}
                if ($(this).val() == "" && current_effect != "") {

                    resetCanvas();
                }
                current_effect = $(this).val();
            });

            color.addEventListener('change', function (e) {
                paint_ctx.shadowColor = e.target.value;
            });
            runCanvas();

        }(window, document));

    </script>

</body>

</html>